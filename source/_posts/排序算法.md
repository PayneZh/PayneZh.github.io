---
title: 排序算法
date: 2020-10-11 14:33:04
tags: 编程基础
categories: 编程
---

## 排序算法的介绍

排序也称排序算法(Sort Algorithm),排序是将一组数据，依指定的顺序进行排列的过程。
**排序的分类**：
1. 内部排序：

指将需要处理的所有数据都加载到内部存储器中进行排序。
2. 外部排序：

数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。
3. 常见的排序算法分类（见下图）
![图1](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/algorithm/%E6%8E%92%E5%BA%8F%E5%88%86%E7%B1%BB.jpg)

## 算法的时间复杂度

1. 事后统计的方法
这种方法可行，但是有两个问题，一是要想对设计的算法的运行性能进行评测，需要实际运行该程序：而是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快。
2. 事前估算的方法
通过分析某个算法的时间复杂度来判断哪个算法更优。

### 时间频度

时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多，一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)。

举例说明：
比如计算1-100所有数字之和，我们设计两种算法：

```
int total = 0;
int end = 100;
for(int i = 0; i <= end; i++){
	total+=1;
}
```
T(n) = n + 1;
直接结算

```
	total=(1+end)*end/2;
```
T(n) = 1;

忽略常数项：
1. 2n+20和2n随着n变大，执行曲线无限接近，20可忽略
2. 3n+10和3n随着n变大，执行曲线无限接近，10可以忽略

忽略低次项：
1. 2n^2+3n+10和2n^2随着n变大，执行曲线无限接近，可以忽略3n+10
2. n^2+5n+20和n^2随着n变大，执行曲线无限接近，可以忽略5n+20

忽略系数：
1. 随着n值变大，5n^2+7n和3n^2+2n,执行曲线重合，说明这种情况下，5和3可以忽略。
2. 而n^3+5n和6n^3+4n，执行曲线分离，说明多少次方关键。

### 时间复杂度

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记做T(n) = O(f(n)),称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。
2. T(n)不同，但时间复杂度可能相同，如：T(n)=n^2+7n+6与T(n)=3n^2+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n^2)。
3. 计算时间复杂度的方法：

- 用常数1代替运行时间中的所有加法常数。
- 修改后的运行次数函数中，只保留最高阶项
- 去除最高阶项的系数。

常见的时间复杂度
1. 常数阶O(1)
无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O(1)
```
	int i = 1;
	int j = 2;
	++i;
	j++;
	int m = i + j;
```
上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

2. 对数阶O(logn)

```
	int i = 1;
	while(i < n){
		i = i * 2;
	}
```
在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了，假设循环x次之后，i就大于2了，此时这个循环就退出了，也就是说2的x次方等于n，那么x = logn也就是说当循环logn次以后，这个代码就结束了，因此这个代码的时间复杂度为：O(logn)

3. 线性阶O(n)
```
	for(i=1;i<=n;++i){
		j = i;
		j++;
	}
```
这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

4. 线性对数阶O(nlogn)

```
	for(m=1;m<n;m++){
		int i = 1;
		while(i < n){
			i = i * 2;
		}
	}
```
线性对数阶O(nlogn)其实非常容易理解，将时间复杂度O(logn)的代码循环N遍的话，那么它的时间复杂度就是n*O(logn),也就是O(nlogn)

5. 平方阶O(n^2)
```
	for(x=1;x<=n;x++){
		for(i=1;i<=n;i++{
			j = i;
			j++;
		}
	}
```

平方阶O(n^2)就更容易理解了，如果把O(n)的代码再嵌套循环一遍，它的时间复杂度就是O(n^2)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是O(n^2)，如果将其中一层循环的n改成m，那它的时间复杂度就变成了O(m*n)

6. 立方阶O(n^3)

参考上面的O(n^2)去理解就好了，O(n^3)相当于3层的n循环

7. k次方阶O(n^k)

参考上面的O(n^2)去理解就好了，O(n^k)相当于k层的n循环

8. 指数阶O(2^n)

- 常见的算法时间复杂度由小到大依次为：O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(n^k)<O(2^n)<O(n!),随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

### 平均时间复杂度和最坏时间复杂度

1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2. 最坏情况下的时间复杂度称最坏时间复杂度，一般讨论的时间复杂度均是最坏情况下的时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关见下图
![图2](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.jpg)

## 算法的空间复杂度

1. 类似于时间复杂度的讨论，一个算法的空间复杂度（Space Complexity）定义为该算法所耗费的存储空间，它也是问题规模n的函数
2. 空间复杂度（Space Complexity）是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。
3. 在做算法分析时，主要讨论的是时间复杂度，从用户使用体验上看，更看重的程序执行的速度，一些缓存产品（Redis，memcache）和算法（基数排序）本质就是用空间换时间。

## 冒泡排序

基本介绍：
冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前往后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。
因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换，从而减少不必要的比较。

## 选择排序

基本介绍：
选择排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的

思想：选择排序也是一种简单的排序方法，它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]z中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，...，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换,...,第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换,总共通过n-1次，得到一个按顺序码从小到大排列的有序序列。


## 插入排序

基本介绍：
插入排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。
基本思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表

## 希尔排序

基本介绍：
希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。
希尔排序法基本思想
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入顺序算法排序，随着增量的逐渐减少，每组包含的关键词越来越少，当增量减至1时，整个文件恰被分成一组，算法便终止。

## 快速排序

基本介绍：
快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

## 归并排序

基本介绍：
归并排序（Merge-Sort）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分（divide）成一些小的问题然后递归求解，而治（conquer）的阶段则将分的阶段得到的各答案”修补“在一起，即分而治之）。

![图3](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3.jpg)

![图4](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/algorithm/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B32.jpg)