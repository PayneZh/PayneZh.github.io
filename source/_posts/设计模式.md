---
title: 设计模式
date: 2020-09-15 10:48:53
tags: 编程基础
categories: 编程
---

## 设计模式的重要性

软件工程中，**设计模式**是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案，这个术语是由埃里希-伽马等人在1990年代从建筑设计领域引入到计算机科学的

## 设计模式的目的
编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序具有更好的

1. 代码重用性（即相同功能的代码，不用多次编写）
2. 可读性（即编程规范性，便于其他程序员的阅读和理解）
3. 可扩展性（即当需要增加新的功能时，非常的方便，或称为可维护性）
4. 可靠性（即当我们增加新的功能后，对原来的功能没有影响）
5. 使程序呈现高内聚，低耦合的特性

注：设计模式包含了面向对象的精髓，懂了程序设计，你就懂了面向对象分析和设计（OOA/D）的精要

## 设计模式的六大原则

### 开闭原则（Open Close Principle）
1. 基本介绍
- 开闭原则是编程中最基础、最重要的设计原则
- 一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方），用抽象构建框架，用实现扩展细节
- 当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
- 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则

### 里氏代换原则（Liskov Substitution Principle）
1. OO中的继承性的思考和说明：
- 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有子类必须遵守这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
- 继承在给程序设计带来便利的同时，也带来了弊端，比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障
- 在编程中如何正确的使用继承？ **里式替换原则**
2. 基本介绍：

- 里式替换原则在1988年，由麻省理工学院的一位姓里的女士提出
- 如果对每个类型为T1的对象o1,都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时,程序P的行为没有发生变化，那么类型T2是类型T1的子类型，换句话说，所有引用基类的地方必须能透明地使用其子类的对象
- 在使用继承时，遵循里式替换原则，在子类中尽量不要重写父类的方法


### 依赖倒转原则（Dependence Inversion Principle）

1. 基本介绍：
依赖倒转原则是指：
- 高层模块不应该依赖底层模块，二者都应该依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象
- 依赖倒转（倒置）的中心思想是面向接口编程
- 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多，以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，在java中，抽象指的是接口或者抽象类，细节就是具体的实现类
- 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
2. 依赖关系传递的三种方式：
- 接口参数传递
- 构造方法传递
- setter方式传递
3. 注意事项和细节：
- 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
- 变量的声明类型尽量是抽象类或接口，这样我们的变量应用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
- 继承时遵循**里式替换**原则

### 接口隔离原则（Interface Segregation Principle）

1. 基本介绍：
客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上
2. 举例：
类A通过接口interface1依赖类B,类C通过接口interface1依赖类D,如果接口interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。按隔离原则应当这样处理：将接口interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则


### 迪米特法则，又称最少知道原则（Demeter Principle）
1. 基本介绍：
- 一个对象应该对其它对象保持最少的了解
- 类与类关系越密切，耦合度越大
- 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息
- 迪米特法则还有个更简单的定义：只与直接的朋友通信
- 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系，耦合的方法很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友，也就是说，陌生的类最好不要以局部变量的形式出现在类的内部
2. 注意事项和细节
- 迪米特法则的核心是降低类之间的耦合
- 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系

### 合成复用原则（Composite Reuse Principle）

1. 基本介绍：
原则是尽量使用合成/聚合的方式，而不是使用继承

### 单一职责原则

1. 基本介绍：
对类来说的，每一个类应该只负责一项职责，如类A负责两个不通职责：职责1，职责2，当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1,A2
2. 注意事项和细节：
- 降低类的复杂度，一个类只负责一项职责
- 提高类的可读性，可维护性
- 降低变更引起的风险
- 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：只有类中方法数量足够少，可以在方法级别保持单一职责原则

## 设计原则核心思想
- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
- 针对接口编程，而不是针对实现编程
- 为了交互对象之间的松耦合设计而努力

## 类图

1. 依赖关系

只要是在类中用到了对方，那么他们之间就存在依赖关系，如果没有对方，连编译都通过不了。
依赖关系包括（1.如果是类的成员属性，2.如果是方法的返回类型，3.是方法接受的参数类型，4.方法中局部变量使用到
2. 泛化关系

泛化关系实际上就是继承关系，他是**依赖关系的特例**

3. 实现关系

实现关系实际上就是A类实现B类，他是**依赖关系的特例**

4. 关联关系

- 关联关系实际上就是类与类之间的联系，它是**依赖关系的特例**。
- 关联关系具有导航型：即双向关系或单向关系。
- 关系具有多重性：如“1”（表示有且仅有一个），“0...”（表示0个或多个），“0,1”（表示0个或者一个），“n...m”(表示n到m个都可以)，“m...”表示至少m个
单向一对一关系
```

public class Person{
	private IDCard card,
}
public class IDCard{}
```
双向一对一关系
```
public class Person{
	private IDCard card;
}
public class IDCard{
	private Person person;
}
```

5. 聚合关系

聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开，聚合关系是**关联关系的特例**，所以他具有关联的导航性与多重性。
如：一台电脑由键盘，显示器，鼠标等组成，组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示。
```
public class Computer{
	private Mouse mouse;
	private Monitor monitor;
	public void setMouse(Mouse mouse){
		this.mouse = mouse;	
	}
	public void setMonitor(Monitor monitor){
		this.monitor = monitor;	
	}
}

```

6. 组合关系

- 组合关系也是整体与部分的关系，但是整体与部分不可以分开。
- 再看一个案例：再程序中我们定义实体：Person与IDCard,Head,那么Head和Person就是组合，IDCard和Person就是聚合。
- 但是如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard和Person就是组合了。
```
public class Person{
	private IDCard card;
	private Head head = new Head();
}
public class IDCard{}
public class Head{}
```

## 设计模式分类

1. **创建型模式**：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2. **结构型模式**：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
3. **行为型模式**：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）。

注意：不同的书籍上对分类和名称略有差别

### 单例模式

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得某对象的方法（静态方法）。

有八种方式
1.饿汉式（静态常量）
优点：这种写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步问题
缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终从未使用过这个实例，则会造成内存的浪费
这种方式基于classloader机制避免了多线程的同步问题，不过，instance在类加载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类加载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到Lazy Loading的效果
结论：这种单例模式可用，可能造成内存浪费
```
class Singleton{
//1.构造器私有化，外部不能new
	private Singleton(){

	}

	private final static Singleton instance = new Singleton()

	public static Singleton getInstance(){
		return instance;
	}
}
```

2.饿汉式（静态代码块）
```
class Singleton{
    //私有化构造器，不能在其它地方new
    private Singleton() {
    }

    private final static Singleton instance;

    static {
        instance = new Singleton();
    }

    public static Singleton getInstance(){
        return instance;
    }

```
优缺点说明：
1). 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码。初始化类的实例，优缺点和上面是一样的。
2). 结论：这种单例模式可用，但是可能造成内存浪费

3.懒汉式（线程不安全）
```
class Singleton{
    private static Singleton instance;

    private Singleton() {
    }

    //提供一个静态的公有方法，当使用到该方法时，才去创建instance
    //懒汉式，线程不安全
    public static Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}

```
优缺点说明：
1). 起到了Lazy Loading的效果，但是只能在单线程下使用。
2). 如果在多线程下，一个线程进入了if(instance == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。
3). 结论：在实际开发中。不要使用这种方式。

4.懒汉式（线程安全）
```
class Singleton{
    private static Singleton instance;

    private Singleton() {
    }

    //提供一个静态的公有方法，当使用到该方法时，才去创建instance
    //懒汉式，线程安全
    public static synchronized Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}

```
优缺点说明：
1). 解决了线程不安全问题
2). 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步，而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了，方法进行同步效率太低
3). 结论：在实际开发中，不推荐使用这种方式

5.双重检查
```
class Singleton{
    private static volatile Singleton instance;

    private Singleton() {
    }

    //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题
    //懒汉式，线程安全
    public static synchronized Singleton getInstance(){
        if (instance == null){
            synchronized (Singleton.class){
                if (instance == null){
                    instance = new Singleton();
                }
            }

        }
        return instance;
    }
}

```
优缺点说明：
1). Double-Check概念是多线程并发中常使用的，如代码中所示，我们进行了两次if(instance == null)检查，这样就可以保证线程完全了。
2). 这样，实例化代码只用执行一次，后面再次访问时，判断if(instance == null)，直接return实例化对象，也避免了反复进行方法同步
3). 线程安全：延迟加载，效率较高
4). 结论：在实际开发中，推荐使用这种方式



6.静态内部类
```
class Singleton{
    private Singleton() {
    }
    //写一个静态内部类，该类中有一个静态属性Singleton
    private static class SingletonInstance{
        private static final Singleton instance = new Singleton();
    }

    public static  Singleton getInstance(){
        return SingletonInstance.instance;
    }
}

```
优缺点说明：
1). 这种方式采用了类加载的机制来保证初始化实例时只有一个线程。
2). 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。
3). 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
4). 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
5). 结论：在实际开发中，推荐使用这种方式

7.枚举
```
enum Singleton{
    INSTANCE;
    public void sayOk(){
        System.out.println("OK~");
    }
}

```
优缺点说明：
1). 这借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
2). 这种方式是Effective Java作者Josh Bloch提倡的方式。
3). 结论：推荐使用。


**单例模式注意事项和细节说明**
1. 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
2. 当想实例化一个单例类的时候，必循要记住使用相应的获取对象的方法，而不是使用new
3. 单例模式使用的场景，需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即：重量级对象）。但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）

### 简单工厂模式

传统方式的优缺点：
1. 优点是比较好理解，简单易操作。
2. 缺点是违反了设计模式ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码。

基本介绍：
1. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。
2. 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）
3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

### 工厂方法模式

基本介绍：
定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类。

### 抽象工厂模式

1. 定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步抽象）。
4. 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

### 原型模式

传统方式解决克隆羊问题
1. 优点是比较好理解，简单易操作
2. 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低。
3. 总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活
4. 改进的思路分析：

思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone()的java类必须要实现一个接口Cloneable,该接口表示该类能够复制且具有复制的能力

原型模式-基本介绍
1. 原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象,无需知道如何创建的细节。
3. 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来实现创建，即对象clone()
4. 形象的理解：孙大圣拔出猴毛，变出其它孙大圣。

原型模式在Spring框架中源码分析
1. Spring中原型bean的创建，就是原型模式的应用（需要注解指定，默认是单例模式）。

深入讨论-浅拷贝和深拷贝
1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。
3. 前面我们克隆羊就是浅拷贝
4. 浅拷贝是使用默认的clone()方法来实现。

深拷贝基本介绍
1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象，也就是说，对象进行深拷贝要对整个对象进行拷贝
3. 深拷贝实现方式1：重写clone方法来实现深拷贝
4. 深拷贝实现方式2：通过对象序列化实现深拷贝

原型模式的注意事项和细节
1. 创建型的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2. 不用重新初始化对象，而是动态地获得对象运行时的状态。
3. 如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需修改代码。
4. 在实现深克隆的时候可能需要比较复杂的代码
5. 缺点：需要为每一个类配置一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。

### 建造者模式

盖房项目需求

需要建房子：这一过程为打桩、砌墙、封顶
房子有各种各样的，比如普通房、高楼、别墅、各种房子的过程虽然一样，但是要求不要相同的。
请编写程序，完成需求

传统方式的问题分析
1. 优点是比较好理解，简单易操作。
2. 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好，也就是说，这种设计方案，把产品（即：房子）和创建产品的过程（即：建房子流程）封装在一起，耦合性增强了。
3. 解决方案，将产品和产品建造过程解耦->建造者模式。

基本介绍
1. 建造者模式(Builder Pattern)又叫生成器模式，是一种对象构建模式，它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象
2. 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

建造者模式的四个角色
1. Product(产品角色)：一个具体的产品对象。
2. Builder(抽象建造者)：创建一个Product对象的各个部件指定的接口/抽象类。
3. ConcreteBuilder(具体建造者)：实现接口，构建和装配各个部件。
4. Director（指挥者）：构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。


建造者模式在JDK的应用和源码分析
java.lang.StringBuilder中的建造者模式

建造者模式的注意事项和细节
1. 客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
2. 每一个具体建造者都相对独立，而与其它的具体建造者无关，因此可以很方便的替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。
3. 可以更加精细的控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
4. 增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品 之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下要考虑是否选择建造者模式。
7. 抽象工厂模式VS建造者模式
抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品，具有不同分类维度的产品组合，采用抽象工厂模式不需要关系构建过程，只关心什么产品由什么工厂生产即可，而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

### 适配器模式

基本介绍

1. 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为包装器（Wrapper）
2. 适配器模式属于结构型模式
3. 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。

工作原理

1. 适配器模式：将一个类的接口转换成另一个接口。让原本接口不兼容的类可以兼容
2. 从用户的角度看不到被适配者，是解耦的。
3. 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。
4. 用户收到反馈结果、感觉只是和目标接口交互

类适配器模式

基本介绍：Adapter类，通过继承src类，实现dst类接口，完成src->dst的适配。
类适配器模式应用实例
1. 应用实例说明：以生活中充电器的例子来讲解适配器，充电器本身相当于Adaper，220V交流电相当于src（即被适配者），我们的dst(即目标)是5V直流电。
2. 注意事项和细节：Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性；src类的方法在Adapter中都会暴露出来，也增加了使用过的成本。由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。

对象适配器模式

1. 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src->dst的适配
2. 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。
3. 对象适配器模式是适配器模式常用的一种。
4. 注意事项和细节：对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口，使用成本更低，更灵活。

接口适配器模式

1. 一些书籍称为：适配器模式（Default Adapter Pattern）或缺省适配器模式
2. 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。
3. 适用于一个接口不想使用其所有的方法的情况。

适配器模式在SpringMVC框架应用的源码分析
1. SpringMVC中的HandlerAdapter，就使用了适配器模式。
2. 使用HandlerAdapter的原因分析：可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断使用if else 来进行判断是哪一种子类然后执行，那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。

注意事项和细节

1. 三种命名方式，是根据src是以怎样的形式给到Adapter(在Adapter里的形式)来命名的。
2. 类适配器：以类给到，在Adapter里，就是将src当作类，继承。
   对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有
   接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现
3. Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。
4. 实际开发中，实现起来不拘泥于我们讲解的三种经典形式。

### 桥接模式

手机操作问题
现在对不同手机类型的不同品牌实现操作编程（比如：开关机、上网、打电话等）。
如图：
![图1](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E6%89%8B%E6%9C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

传统方案解决手机操作问题
1. 扩展性问题（类爆炸），如果我们再增加手机的样式（旋转式），就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式下增加。
2. 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码的维护成本
3. 解决方案-使用桥接模式
![图2](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E6%89%8B%E6%9C%BA%E7%B1%BB%E5%9B%BE.jpg)

桥接模式基本介绍
1. 桥接模式（Bridge模式）是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
2. 是一种结构型设计模式
3. Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现（implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。

桥接模式的原理类图
![图3](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B1%BB%E5%9B%BE.jpg)
1. Client类：桥接模式的调用者
2. 抽象类（Abstraction）维护了implementor即它的实现类ConcreteImplementorA...,二者是聚合关系，Abstraction充当桥接类
3. RefinedAbstraction:是Abstraction抽象类的子类。
4. implementor：行为实现类的接口
5. ConcreteImplementorA/B:行为的具体实现类
6. 从UML图：这里的抽象类和接口是聚合关系，其是调用和被调用关系。

桥接模式在JDBC的源码剖析
1. Jdbc的Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有Mysql的Driver，Oracle的Driver,这些就可以当做实现接口类。


注意事项和细节

1. 实现了抽象和实现部分的分离，从而极大的提高了系统的灵活性，让抽象部分和实现部分独立出来，这有助于系统进行分层设计，从而产生更好的结构化系统。
2. 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。
3. 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。
4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。
5. 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。 

桥接模式其它应用场景
1. 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。
2. 常见的应用场景
 - JDBC驱动程序
 - 银行转账系统：转账分类：网上转账、柜台转账、ATM转账。转账用户类型：普通用户、银卡用户、金卡用户。
 - 消息管理： 消息类型：即时消息，延时消息。消息分类：手机短信，邮件消息，QQ消息。

### 装饰器模式

星巴克咖啡订单项目
咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack（美式咖啡）、Decaf(无因咖啡)。
调料： Milk、Soy(豆浆)、Chocolate
要求在扩展新的咖啡种类时，具有良好的扩展性，改动方便、维护方便
使用OO来计算不同种类咖啡的费用：客户可以点单品咖啡，也可以单品咖啡+调料组合。
方案1-解决星巴克咖啡订单问题分析：
1. Drink是一个抽象类，表示饮料
2. des就是对咖啡的描述，比如咖啡的名字
3. cost（）方法就是计算费用，Drink类中做成一个抽象方法
4. Decaf就是单品咖啡，继承Drink，并实现cost
5. Espresso &&Milk就是单品咖啡加调料，这个组合很多
6. 问题：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸。

![图4](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E6%98%9F%E5%B7%B4%E5%85%8B%E5%92%96%E5%95%A1%E8%AE%A2%E5%8D%95%E9%A1%B9%E7%9B%AE.jpg)
方案2-解决星巴克咖啡订单（好点）：
前面分析到方案1因为咖啡单品+调料组合会造成类的倍增。因此可以做改进，将调料内置到Drink类，这样就不会造成类数量过多。从而提高项目的维护性
![图5](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E6%98%9F%E5%B7%B4%E5%85%8B%E5%92%96%E5%95%A1%E8%AE%A2%E5%8D%95%E9%A1%B9%E7%9B%AE%E7%A8%8D%E5%BE%AE%E6%94%B9%E8%BF%9B.jpg)
说明：milk、soy、chocolate可以设计为Boolean，表示是否要添加相应的调料。
方案2-的问题分析
1. 方案2可以控制类的数量，不至于造成很多的类
2. 在增加或者删除调料种类时，代码的维护量很大。
3. 考虑到用户可以添加多份调料时，可以将hasMilk返回一个对应的int
4. 考虑使用装饰器模式

装饰器模式定义
装饰器模式，动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰器模式也体现了开闭原则（ocp）

装饰器模式原理
1. 装饰器模式就像打包一个快递：
主体：比如：陶瓷、衣服（Component）//被装饰者
包装：比如：报纸填充、塑料薄膜、纸板、木板（Decorator）
2. Component
主体： 比如类似前面的Drink
3. ConcreteComponent和Decorator：
ConcreteComponent：具体的主体，比如前面的各个单品咖啡
Decorator：装饰者，比如各调料
4. 在如图的Component与ConcreteComponent之间，如果ConcreteComponent类很多，还可以设计一个缓冲层，将共有的部分提取出来，抽象出一个类。
![图6](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.jpg)

装饰器模式在JDK应用

![图7](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/inputstream%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg)

public abstract class InputStream implements Closeable{}//是一个抽象类，即Component
public class FilterInputStream extends InputStream{ //是一个装饰者类Decorator
protected volatile InputStream in -被装饰的对象
}
class DataInputStream extends FilterInputStream implements DataInput{//FilterInputStream 子类，也继承了被装饰的对象in
}

### 组合模式

学校院系展示需求
编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，如图：
![图8](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B.jpg)

基本介绍
1. 组合模式（Composite Pattern）,又叫部分整体模式，它创建了对象组的树形结构。将对象组合成树状结构以表示“整体-部分”的层次关系
2. 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
3. 这种类型的设计模式属于结构型模式。
4. 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。

组合模式原理类图：
![图9](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.jpg)
对原理结构图的说明-即（组合模式的角色及职责）
1. Component：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口，默认行为用于访问和管理Component子部件，Component可以是抽象类或接口
2. Leaf:在组合中表示叶子节点，叶子节点没有子节点
3. Composite：非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加（add）,删除等

组合模式在JDK集合的源码分析
1. Java的集合类-HashMap就使用了组合模式

- Map就是一个抽象的构建（类似我们的Component）
- HashMap是一个中间的构建（Composite），实现/继承了相关方法put,putall
- Node是HashMap的静态内部类，类似Leaf叶子节点，这里就没有put，putall
static class Node<K,V> implements Map.Entry<K,V>

组合模式的注意事项和细节
1. 简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题
2. 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。
3. 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。
4. 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式
5. 要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式

### 外观模式

影院管理项目
组建一个家庭影院：
DVD播放器、投影仪、自用屏幕、环绕立体声、爆米花机，要求完成使用家庭影院的功能，其过程为：
- 直接用遥控器，统筹各设备开关
- 开爆米花机
- 放下屏幕
- 开投影仪
- 开音响
- 开DVD,选dvd
- 去拿爆米花
- 调暗灯光
- 播放
- 观影结束后，关闭各种设备。

传统方式解决影院管理
![图10](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E5%BD%B1%E9%99%A2%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9B%BE.jpg)
传统方式问题分析：
在ClientTest的main方法中，创建各个子系统的对象，并直接去调用子系统（对象）相关方法，会造成调用过程混乱，没有清晰的过程。不利于在ClientTest中，去维护对子系统的操作。
解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面（比如在高层接口提供四个方法ready,play,pause,end),用来访问子系统中的一群接口，也就是说就是通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节=>外观模式

基本介绍：
1. 外观模式（Facade），也叫“过程模式”：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
2. 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。
![图11](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B1%BB%E5%9B%BE.jpg)
原理类图的说明（外观模式的角色）
1. 外观类（Facade）:为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给适当子系统对象。
2. 调用类（Client）:外观接口的调用者
3. 子系统的集合：指模块或者子系统，处理Facade对象指派的任务，他是功能的实际提供者。

外观模式解决影院管理说明：
1. 外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的，比如：在pc上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）
2. 外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。
3. 示意图说明

![图12](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

外观模式在Mybatis框架应用的源码分析
1. Mybatis中的Configuration去创建MetaObject对象使用到外观模式

![图13](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/Mybatis%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png)

外观模式的注意事项和细节
1. 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性。
2. 外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展
3. 通过合理的使用外观模式，可以帮我们更好的划分访问的层次。
4. 当系统需要进行分层设计时，可以考虑使用Facade模式
5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性。
6. 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的。

### 享元模式

展示网站项目需求
小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：
1. 有客户要求以新闻的形式发布
2. 有客户要求以博客的形式发布
3. 有客户希望以微博公众号的形式发布

传统方案解决网站展现项目
![图14](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%A1%88.jpg)

传统方案解决网站展现项目-问题分析
1. 需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费
2. 解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源。
3. 对于代码来说，由于是一份实例，维护和扩展都更加容易
4. 上面的解决思路就可以使用**享元模式**来解决

基本介绍
1. 享元模式（Flyweight Pattern）也叫蝇量模式，运用共享技术有效的支持大量细粒度的对象。
2. 常用于系统底层开发，解决系统的性能问题，像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
3. 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时，不需总是创建新对象，可以从缓冲池里拿，这样可以降低系统内存，同时提高效率。
4. 享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式

![图15](https://github.com/PayneZh/MarkDownPhotos/raw/master/res/designpattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B1%BB%E5%9B%BE.jpg)
对原理图的说明（模式的角色及职责）：
- FlyWeight是抽象的享元角色，它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现
- ConcreteFlyWeight是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务
- UnSharedConcerteFlyWeight是不可共享的角色，一般不会出现在享元工厂。
- FlyWeightFactory享元工厂类，用于构建一个池容器（集合），同时提供从池中获取对象方法

享元模式在JDK-Integer的应用源码分析
1. Integer.valueOf()源码分析

享元模式的注意事项和细节
1. 在享元模式这样理解，“享”就表示共享，“元”表示对象
2. 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式
3. 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储
4. 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
5. 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而内部状态具有固化特性，不应该随着外部状态的改变而改变，这是我们使用享元模式需要注意的地方。
6. 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。
7. 享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池。